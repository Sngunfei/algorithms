# -*- encoding:utf-8 -*-

"""
常用的字符串算法
"""


    def kmp(s, t):
        """
        KMP算法，核心是计算最大部分匹配表。
        动机：暴力匹配，每次移动一位，浪费了很多时间，能不能一次移动很多位？
        目的：移动很多位，如何保证移动过程中的位置不是我们想要的？怎么计算出这个step数？
        方法：建立前缀后缀匹配表。发生冲突后，冲突之前的位置一定是匹配正确的，那么如何利用这个信息呢？
              既然我们知道了冲突位置之前的字符，假设现在有长度为k的字符已经匹配上了，它有k-1个后缀字符串，
              也有k-1个前缀字符串，找到两者交集中最长的，假如长度为t，那么我直接将那个前缀字符串移动到对
              应的后缀字符串上，它俩肯定匹配。因为是前缀，所以字符串的前面长度为t的部分就不用管了，直接在
              新的位置上t+1上继续匹配即可。
        :return:
        """

        # 在t中查找s是否存在
        NEXT = [0] * (len(s) + 1)
        NEXT[0] = -1
        i, j = 0, -1

        while i < len(s):
            # 可以看作双指针，j在前面，i在后面，如果两个位置相同，都同时前进一步
            if j == -1 or s[i] == s[j]:
                i += 1
                j += 1
                NEXT[i] = j  # 前i个字符所构成的字符串的前缀后缀最大匹配长度
            else:
                """
                # 如果两个指针处位置不同，那匹配就要作废，但不是完全作废，这时可以看成
                # 字符串内部的KMP过程，前指针要和后指针匹配，
                # 这时就体现出了next数组和PMT数组的区别，因为PMT时候考虑最后位置的，但是这个位置
                恰恰发生了冲突，实际上next[i] = PMT[i-1]，这就是原因。
                """
                j = NEXT[j]  # j = PMT[j-1]，时刻记住 前缀和后缀的最大匹配长度
                """
                [prefix][a] ... [postfix][b], a != b, 冲突
                但是prefix是和postfix一样的，所以应该找到prefix的前缀和postfix的后缀的最大匹配长度，
                即prefix自身的最大匹配长度(递归问题？)，即Next[j]
                """

        i, j = 0, 0
        while i < len(s) and j < len(t):
            if i == -1 or s[i] == t[j]:
                i += 1
                j += 1
            else:
                i = NEXT[i]  # i的位置发生变化，j不动
        if i == len(s):
            return j - i
        return -1


def reverse_order():
    """
    单词逆序，"abc def" => "cba fed"
    :return:
    """
    pass


if __name__ == '__main__':
    s = "ababab"
    t = "ccababcabababababab"
    print(kmp(s, t))
